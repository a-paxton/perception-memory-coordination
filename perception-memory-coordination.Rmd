---
title: "Interpersonal coordination in perception and memory"
author: "A. Paxton, T. J. H. Morgan, J. Suchow, & T. L. Griffiths"
output:
  pdf_document: 
    number_sections: yes
  html_document:
    keep_md: yes
    number_sections: yes
---

This R markdown provides the basis for our manuscript, "Interpersonal coordination in perception and memory" (Paxton, Morgan, Suchow & Griffiths, *in preparation*).

To run these analyses from scratch, you will need the following files:

* `./data/`: Contains experimental data. All data for included dyads are freely available in the OSF repository for the project: `https://osf.io/8fu7x/`.
* `./supplementary-code/required_packages-pmc.r`: Installs required libraries, if they are not already installed. **NOTE**: This should be run *before* running this script.
* `./supplementary-code/libraries_and_functions-pmc.r`: Loads in necessary libraries and creates new functions for our analyses.

Additional files will be created during the initial run that will help reduce processing time. Several of these files are available as CSVs from the OSF repository listed above.

**Code written by**: A. Paxton (University of California, Berkeley)

**Date last modified**: 26 October 2017

***

# Data preparation

***

## Preliminaries

```{r prep-prelim, warning = FALSE, error = FALSE, message = FALSE}

# clear our workspace
rm(list=ls())

# read in libraries and create functions
source('./supplementary-code/required_packages-pmc.r')
source('./supplementary-code/libraries_and_functions-pmc.r')

```

***

## Concatenate experiment files

```{r concatenate-data, warning = FALSE, error = FALSE, message = FALSE}

# get list of individual experiments included in the data
experiment_files = list.dirs('./data', recursive=FALSE)

# concatenate the files
vector_files = data.frame()
info_files = data.frame()
questionnaire_files = data.frame()
node_files = data.frame()
for (experiment in experiment_files){
  
  # read in the next experiment's files and add ID to each
  exp_id = strsplit(as.character(experiment),"/|-")[[1]][3]
  next_vector = read.table(paste(experiment,'/vector.csv',sep=''), sep=',',
                           header=TRUE, stringsAsFactors = FALSE) %>%
    mutate(experiment = exp_id)
  next_info = read.table(paste(experiment,'/info.csv',sep=''), sep=',',
                         header=TRUE, stringsAsFactors = FALSE) %>%
    mutate(experiment = exp_id)
  next_q = read.table(paste(experiment,'/question.csv',sep=''), sep=',',
                           header=TRUE, stringsAsFactors = FALSE) %>%
    mutate(experiment = exp_id)
  next_node = read.table(paste(experiment,'/node.csv',sep=''), sep=',',
                           header=TRUE, stringsAsFactors = FALSE) %>%
    mutate(experiment = exp_id)

  # append to group files
  vector_files = rbind.data.frame(vector_files, next_vector)
  info_files = rbind.data.frame(info_files, next_info)
  questionnaire_files = rbind.data.frame(questionnaire_files, next_q)
  node_files = rbind.data.frame(node_files, next_node)

}

```

## Identify dyads from vector data

In order to figure out which participants' nodes were connected to one another in dyads, we use the vectors created between nodes (excluding the stimulus-creating node). We then use that information to identify which stimuli were sent to which dyads.

```{r identify-dyads, warning = FALSE, error = FALSE, message = FALSE}

# use the vectors connecting the nodes to identify pairs
vector_df = vector_files %>%
  
  # convert time to integer and winnow out unnecessary variables and nodes
  mutate(t = round(as.numeric(ymd_hms(creation_time)), 0)) %>%
  select(experiment, t, origin_id, destination_id, network_id) %>%
  dplyr::filter(!origin_id == 1) %>%
  
  # find pairs from vector files
  group_by(experiment, t) %>%
  mutate(min_id = pmin(origin_id,destination_id)) %>%
  mutate(max_id = pmax(origin_id,destination_id)) %>%
  ungroup() %>%
  
  # get unique pairs and number them
  select(-origin_id, -destination_id) %>%
  distinct() %>%
  mutate(dyad = seq_along(min_id)) %>%

  # gather the participants into a single column
  gather(key="id",value="participant", min_id, max_id) %>%
  select(-id)

# figure out which stimuli were sent to which dyads
dyad_df = info_files %>%
  mutate(t = round(as.numeric(ymd_hms(creation_time)), 0)) %>%
  dplyr::filter(origin_id == 1) %>%
  select(experiment, t, contents) %>%
  full_join(., vector_df,
            by = c('experiment', 't')) %>%
  select(-t)

```

## Prepare dataframe

We now take the concatenated files and begin processing, including de-duplication of dataset.

The structure of the experiment sometimes led to near-duplicate rows to be sent to the server to manage partner communication. We must now identify these near-duplicates and strip them out. We can best identify these by using the `response_counter` variable: A properly de-duplicated dataset should have only 1 row per `response_counter` value in each trial for each participant.

```{r process-infos, warning = FALSE, error = FALSE, message = FALSE}

info_df = info_files %>% ungroup() %>%
  
  # filter out stimulus nodes
  dplyr::filter(!origin_id == 1) %>%
  
  # convert time and get rid of unnecessary variables
  mutate(t = round(as.numeric(ymd_hms(creation_time)), 0)) %>%
  select(experiment, t, property3, origin_id, network_id, contents) %>%
    
  # read in `contents` as JSONs
  cbind(., jsonlite::stream_in(textConnection(.$contents))) %>%

  # rename a whole slew of variables
  dplyr::rename(participant = origin_id,
                trial_type = trialType,
                trial_number = trialNumber,
                guess_counter = guessCounter,
                response_counter = responseCounter,
                accept_type = acceptType,
                response_type = responseType) %>%
  
  # get rid of unnecessary variables and arrange rows
  select(-property3, -finalAccuracy, -contents) %>%
  dplyr::arrange(experiment, participant, trial_number, response_counter) %>%
  
  # remove the automatically generated infos that produced NAs in `guess`
  dplyr::filter(!is.na(guess)) %>%
  
  # determine uniqueness without considering time or response_type
  group_by(experiment, participant, network_id, trial_type,
           trial_number, guess_counter, response_counter) %>%
  summarise_all(first) %>%
  ungroup() %>%
  
  # replace NAs from guesses and calculate error with each guess
  mutate(guess = replace(guess, guess<0, NA)) %>%
  mutate(guess_error = length - guess) %>%
  
  # merge info dataframe with dyad number information
  full_join(., dyad_df,
            by = c('experiment', 'participant','network_id')) %>%
  dplyr::rename(stimulus_list = contents)

```

```{r print-sanity-check-for-duplicate-issues, invisible=TRUE, echo=FALSE}

# sanity check
sanity_df = info_df %>% ungroup() %>%
  
  # count number of times we see the same response counter
  group_by(experiment, participant, trial_type, trial_number, guess_counter, response_counter) %>%
  summarise(n = n()) %>%
  ungroup() %>%
  
  # filter to include only test-condition duplicates
  dplyr::filter(n!=1 & trial_type=="test") %>%
  
  # join with the main dataset to check it out
  inner_join(., info_df, 
             by = c("experiment", "participant", "trial_type", 
                    "trial_number", "guess_counter", "response_counter")) %>%
  
  # identify whether any identified duplicate rows have diferent accept_type values
  group_by(experiment, participant, trial_type, trial_number, guess_counter, response_counter) %>%
  dplyr::filter(length(unique(accept_type))!=1) %>%
  ungroup()

# print sanity check
cat('Problematic rows identified (i.e., duplicates with differing accept types): ',dim(sanity_df)[1],sep='')

```

## Identify and winnow down data to usable dyads

Next, we identify all dyads in which both participants responded the same number of times. This ensures that we include only dyads who experienced the full and correct experimental protocol.

```{r identify-complete-dyads}

# identify usable dyads
usable_dyads = info_df %>%
  
  # count the number of infos and trials per participant
  group_by(experiment,participant) %>%
  summarise(trials = max(trial_number),
            dyad = ifelse(length(unique(dyad)==1),
                          unique(dyad),
                          NA),
            infos = n()) %>%
  ungroup() %>%
  na.omit() %>%
  
  # count the infos sent by each participant in each dyad
  group_by(experiment, dyad) %>%
  mutate(participant = paste('p',(participant - min(participant)),sep='')) %>%
  spread(key = participant, value = infos) %>%
  ungroup() %>%
  mutate(difference_in_responses = abs(p1-p0)) %>%
  
  # filter out anyone who didn't have the same number of infos and who didn't complete 24 trials
  dplyr::filter(trials==24 & difference_in_responses==0) %>%
  na.omit()

```

Now that we've figured out which dyads we should use, let's winnow down the dataframe to include only those dyads.

```{r winnow-data}

# winnow and recorder columns
winnowed_info_df = info_df %>%
  dplyr::filter(dyad %in% usable_dyads$dyad) %>%
  mutate(t = round(t,-1)) %>%
  select(experiment, t, dyad, participant, 
         trial_type, trial_number, response_counter, guess_counter, accept_type, 
         length, guess, guess_error, response_type, network_id) %>%
  na.omit()

winnowed_info_df = unique(setDT(winnowed_info_df), by = c('experiment', 'dyad', 'participant', 
         'trial_type', 'trial_number', 'response_counter', 'guess_counter', 'accept_type', 
         'length', 'guess', 'guess_error', 'response_type', 'network_id'))

```

```{r print-usable-dyads, invisible=TRUE, echo=FALSE}

unique_included_dyads = winnowed_info_df %>% ungroup() %>%
  select(experiment, dyad) %>%
  distinct()

cat('Total dyads with strictly paired data for all trials: ',dim(unique_included_dyads)[1], sep='')

```

For sanity, let's also check that everyone included in our winnowed dataset completed both training and test trials.

```{r sanity-check-for-training-and-test}

# ensure that everyone completed both training and test
only_one_trial_type = winnowed_info_df %>% ungroup() %>%
  select(experiment, participant, trial_type) %>%
  distinct() %>%
  group_by(experiment, participant) %>%
  summarize(n=n()) %>%
  dplyr::filter(n!=2)

```

```{r print-problem-participants, invisible=TRUE, echo=FALSE}

cat('Included participants who did not undergo training and testing rounds: ',dim(only_one_trial_type)[1], sep='')

```

## Add questionnaire data

In the experiment's current form, different tables include different information, and some tables present the same information under different labels. This is true for questionnaire data. To accurately pair individuals' guess data with their questionnaire responses, we match the `participant_id` variables in `node_df` and `question_df`, and we join the `id` variable in `node_df` with the `participant` variable in `info_df`.

```{r add-questionnaire-data}

# clean up questionnaire data by converting the stringified JSONs to a new variable
question_df = questionnaire_files %>% ungroup() %>%
  select(experiment, participant_id, response) %>%
  cbind(., jsonlite::stream_in(textConnection(.$response))) %>%
  select(-response)

# clean up the node dataframe
node_df = node_files %>% ungroup() %>%
  select(experiment, participant_id, id) %>%
  na.omit()

# join questionnaire data wth infos and remove any participants whose survey data we don't have
winnowed_info_df = left_join(question_df, node_df,
                                by=c('experiment','participant_id')) %>%
  left_join(winnowed_info_df, .,
                              by=c('experiment','participant' = 'id')) %>%
  drop_na(cooperative_partner, cooperative_self, trust_partner, trust_self, engagement, difficulty)

```

```{r identify-questionnaire-dyads}

# identify how many dyads have matching infos and complete questionnaire data
usable_question_dyads = winnowed_info_df %>% ungroup() %>%
  select(experiment, dyad, participant) %>%
  distinct() %>%
  group_by(experiment, dyad) %>%
  summarise(included_p = n()) %>%
  ungroup() %>%
  dplyr::filter(included_p==2)

# if needed, remove dyads who didn't have questionnaire data
winnowed_info_df = winnowed_info_df %>% ungroup() %>%
  dplyr::filter(dyad %in% usable_question_dyads$dyad)

```

```{r print-quesionnaire-dyads, invisible=TRUE, echo=FALSE}

cat('Total dyads with all guess and questionnaire data: ',dim(usable_question_dyads)[1], sep='')

```

## Create unique dyad and participant IDs across all experiments

Dallinger provides numeric IDs for each participant that are unique only within each experiment. Therefore, we create participant and dyad identifiers that are unique across the entire dataset.

```{r create-unique-ids}

# create unique dyad IDs
unique_dyad_ids = winnowed_info_df %>% ungroup() %>%
  select(experiment, dyad) %>%
  distinct() %>%
  mutate(unique_dyad = row_number())

# create unique participant IDs
unique_participant_ids = winnowed_info_df %>% ungroup() %>%
  select(experiment, participant) %>%
  distinct() %>%
  mutate(unique_participant = row_number())

# merge both into the main dataframe and rename
winnowed_info_df = right_join(unique_participant_ids, winnowed_info_df,
                             by=c('experiment', 'participant')) %>%
  right_join(unique_dyad_ids, ., by=c('experiment','dyad')) %>%
  dplyr::rename(original_participant = participant,
                original_dyad = dyad,
                participant = unique_participant,
                dyad = unique_dyad) %>%
  dplyr::arrange(experiment, participant, trial_number, response_counter)

```

## Increment all counters by 1

Data were collected using Pythonic counters (i.e., starting from 0). We'll here update the dataframe to reflect R conventions (i.e., starting from 1).

```{r r-counters}

winnowed_info_df = winnowed_info_df %>%
  mutate(trial_number = trial_number + 1) %>%
  mutate(response_counter = response_counter + 1) %>%
  mutate(guess_counter = guess_counter + 1)

```

## Normalize error by maximum possible error

Because stimuli line lengths could range from 1-100, each trial provided a bound on the total possible guess error.  As a result, we need to normalize each guess error by the maximum *possible* error for that trial.

```{r normalize-error}

winnowed_info_df = winnowed_info_df %>% ungroup() %>%
  mutate(normalized_error = guess_error/max(abs(100-length),abs(length-100)))

```

## Create training accuracy metric

We next create a training metric that quantifies the *non-directional* improvement over the training rounds. Essentially, this captures the change in relative accuracy over training, regardless of whether participants began by over- or under-estimating line lengths.

```{r training-improvement}

# create a slope to see how quickly they improved
winnowed_info_df = winnowed_info_df %>% ungroup() %>%
  select(participant, trial_type, trial_number, normalized_error) %>%
  na.omit() %>%
  dplyr::filter(trial_type == 'train') %>%
  group_by(participant) %>%
  do(broom::tidy(lm(abs(.$normalized_error) ~ .$trial_number))) %>%
  dplyr::filter(term=='.$trial_number') %>%
  select(participant, estimate) %>%
  dplyr::rename(training_improvement = estimate) %>%
  left_join(winnowed_info_df, .,
            by='participant')

```

```{r plot-training_slopes, echo=FALSE, warning = FALSE, error = FALSE, message = FALSE}

ggplot(dplyr::filter(winnowed_info_df, 
                     trial_type=='train'), 
       aes(x = trial_number,
           y = abs(normalized_error))) +
  geom_line(aes(color=as.factor(participant))) +
  scale_color_viridis(discrete=TRUE) +
  stat_smooth() +
  ylab('Absolute error of guess') +
  scale_x_continuous(breaks=c(1,5,10)) +
  xlab('Training trial') +
  ggtitle('Accuracy of individual participants across training trials') +
  theme(legend.position="none")

```

```{r plot-normalized-error-over-all-trials, echo=FALSE, warning = FALSE, error = FALSE, message = FALSE}

# figure out what our equal x-axis limits will be
x_limit = winnowed_info_df %>% ungroup() %>%
  na.omit() %>%
  summarise(lim = max(abs(normalized_error))) %>%
  .$lim

# create plot
ggplot(winnowed_info_df,
       aes(x = normalized_error)) + 
  geom_histogram(aes(fill = factor(trial_number)),bins=30) +
  scale_fill_viridis(discrete=TRUE,
                     breaks=c('1',
                              '5',
                              '10',
                              '15',
                              '20',
                              '25'),
                     labels=c('First',
                              '',
                              '',
                              '',
                              '',
                              'Last'),
                     name = "Trial") +
  xlab('Normalized error') +
  ylab('Count') +
  xlim(-x_limit, x_limit) +
  ggtitle('Normalized error over all trials')
  
```

## Widen data to include partner's guess

```{r create-column-for-partner-guess}

# create a column for the partner's guess at that time
winnowed_info_df = winnowed_info_df %>% ungroup() %>%
  
  # create participant binary values
  group_by(experiment, dyad) %>%
  mutate(partner_id = (min(participant)+max(participant)) - participant) %>%
  mutate(self_id = participant) %>%
  ungroup() %>%

  # gather into multiple values
  select(self_id, partner_id, normalized_error, trial_number, response_counter) %>%
  dplyr::rename(partner_error = normalized_error) %>%
  distinct() %>%
  
  # merge
  left_join(winnowed_info_df, .,
            by=c('participant'='self_id',
                 'trial_number',
                 'response_counter'))

```


## Export data

```{r export-data}

write.table(winnowed_info_df, './data/winnowed_data.csv', sep=',',
            append = FALSE, quote = FALSE, na = "NA", row.names = FALSE, col.names = TRUE)

```

***

# Data exploration and descriptive statistics

## Preliminaries

```{r exploration-prelim, warning = FALSE, error = FALSE, message = FALSE}

# clear our workspace
rm(list=ls())

# read in libraries and create functions
source('./supplementary-code/libraries_and_functions-pmc.r')

# read in dataset
winnowed_info_df = read.table('./data/winnowed_data.csv', sep=',',header = TRUE)

```

## Descriptive statistics

```{r mean-experiment-duration}

# get list of individual experiments included in the data
experiment_files = list.dirs('./data', recursive=FALSE)

# concatenate the files
participant_files = data.frame()
for (experiment in experiment_files){
  
  # read in the next experiment's files and add ID to each
  exp_id = strsplit(as.character(experiment),"/|-")[[1]][3]
  next_participant = read.table(paste(experiment,'/participant.csv',sep=''), sep=',',
                           header=TRUE, stringsAsFactors = FALSE) %>%
    mutate(experiment = exp_id)

  # append to group files
  participant_files = rbind.data.frame(participant_files, next_participant)
}

# keep only the info we'll need
participant_time_df = participant_files %>%
  select(id, creation_time, end_time, experiment, worker_id, bonus) %>%
  mutate(creation_time = ymd_hms(creation_time)) %>%
  mutate(end_time = ymd_hms(end_time)) %>%
  mutate(duration = (end_time - creation_time)/60)

```

```{r mean-time-for-all-participants}

# identify how long all participants took to complete the experiment
all_participant_time = participant_time_df %>%
  select(-bonus) %>%
  na.omit()
  
```

```{r print-mean-time-for-all-participants, echo=FALSE}
cat('Average participation: ',mean(all_participant_time$duration),' minutes',sep='')
```

```{r mean-time-for-included-participants}

# identify how long included participants took to complete the experiment
included_participant_time = participant_time_df %>%
  na.omit()

```

```{r print-mean-time-for-included-participants, echo=FALSE}
cat('Average participation: ',mean(included_participant_time$duration),' minutes',sep='')
```

We'd intended for each experimental session to last 20 minutes, but the mean duration for included participants in these pilot data is about half of that.  Future pilot studies should increase the number of trials.

## Survey response distributions

```{r plot-histograms-of-survey, echo=FALSE}

ggplot(winnowed_info_df,
       aes(x = cooperative_self)) + 
  geom_histogram(bins=30) +
  xlab('Cooperative rating for self\n(1-10)') +
  ylab('Count') +
  xlim(0, 10) +
  ylim(0, 800) +
  ggtitle("Players' ratings of own cooperativeness")

ggplot(winnowed_info_df,
       aes(x = cooperative_partner)) + 
  geom_histogram(bins=30) +
  xlab("Cooperative rating for partner\n(1-10)") +
  ylab('Count') +
  xlim(0, 10) +
  ylim(0, 800) +
  ggtitle("Players' ratings of partners' cooperativeness")

```

***

# Psychonomics 2017 poster

This section presents the data analysis for the Psychonomics 2017 poster, "Exploring social behavior with Dallinger, an open-source experiment automation tool" (A. Paxton, J. Suchow, T. J. H. Morgan, & T. L. Griffiths, forthcoming). The poster largely presents Dallinger and its specific capabilities of interest to individuals running social psychology experiments, but an analysis of the pilot data from the present study is included as a demonstration.

Because of each dyad in the pilot data only completes 15 trials together, we are unable to do cross-recurrence quantification analysis (CRQA) on the `normalized_error` data. As a result, we instead do cross-correlation. Future pilot studies should increase the number of trials to create a sufficiently long time `normalized_error` time series for each dyad to permit CRQA.

## Preliminaries

Clear the workspace, load in required libraries and functions, and read in the prepared dataset.

```{r analysis-prelim, warning = FALSE, error = FALSE, message = FALSE}

# clear our workspace
rm(list=ls())

# read in libraries and create functions
source('./supplementary-code/libraries_and_functions-pmc.r')

# read in dataset
winnowed_info_df = read.table('./data/winnowed_data.csv', sep=',',header = TRUE)

```

## Data preparation

### Calculate cross-correlation between partners' normalized error

First, we prepare the dataframe for cross-correlation by transitioning from long-form data for both participants within the dyad to using wide-form data for each dyad, with one column for each constituent participant's `normalized_error` at each `trial_number` and `response_counter`.

```{r reformat-df-for-cross-corr}

# strip out unnecessary information
infos = winnowed_info_df %>% ungroup() %>%
  select(experiment,dyad,participant,t,normalized_error,trial_number,response_counter) %>%
  
  # create participant binary values
  group_by(experiment, dyad) %>%
  mutate(partner_id = (min(participant)+max(participant)) - participant) %>%
  mutate(self_id = participant) %>%
  ungroup() %>%
  
  # create binary ID
  group_by(experiment, dyad) %>%
  mutate(partner_binary = participant - min(participant)) %>%
  ungroup() %>%
  
  # remove training trials
  dplyr::filter(trial_number > 10)

# create a dataframe with one dyad per row and separate columns for each participant's error data
binary_dfs = split(infos, infos$partner_binary)
p0_df = data.frame(binary_dfs[[1]]) %>%
  dplyr::rename(error0 = normalized_error) %>%
  select(experiment, dyad, trial_number, response_counter, error0)
p1_df = data.frame(binary_dfs[[2]]) %>%
  dplyr::rename(error1 = normalized_error) %>%
  select(experiment, dyad, trial_number, response_counter, error1)

```

Once the data are prepared, we calculate the cross-correlation coefficients between participants' `normalized_error` during all test rounds. The maximum lag is specified within the `libraries_and_functions-pmc.r` file.

```{r calculate-cross-correlation}

# calculate cross-correlation
ccf_df = full_join(p0_df,p1_df,
                   by= c("experiment", "dyad", "trial_number", "response_counter")) %>%
  
  # calculate cross-correlation for each dyad's error scores
  group_by(experiment,dyad) %>%
  do(ccf = ccf(.$error0, .$error1, lag.max = ccf_max_lag, type = 'correlation',
               na.action = na.pass, plot=FALSE)) %>%
  ungroup() %>%
  
  # extract cross-correlations from the embedded list
  select(ccf) %>%
  dplyr::pull(ccf) %>%
  unlist() %>%
  matrix(.,ncol=length(unique(winnowed_info_df$dyad))) %>%
  
  # convert it into a proper dataframe and select only the coefficients
  as.data.frame() %>%
  slice(1:(ccf_max_lag*2+1)) %>%
  t() %>%
  as.data.frame %>%
  rowid_to_column(var='dyad') %>%

  # rename variables and strip rownames
  rename_(.dots=setNames(names(.), 
                         gsub("V", "", names(.)))) %>%
  remove_rownames() %>%
  
  # reshape the data to combine lag and r
  gather(key = 'lag' , value='r', -dyad) %>%
  mutate_all(as.numeric) %>%
  mutate(lag = lag - ccf_max_lag - 1)

```

Because we don't have any theoretical expectations about or experimental manipulations to change *who* might be leading and following, we ignore directionality for this first-pass analysis.

```{r ignore-lag-directionality}

# ignore lag directionality
ccf_df = ccf_df %>% ungroup() %>%
  mutate(lag = abs(lag)) %>%
  group_by(dyad,lag) %>%
  summarise(r = mean(r))

```

Once we've calculated the cross-correlation coefficients for each dyad, we merge it into the questionnaire data.

```{r merge-into-main-df}

# grab what we need for the cross-correlation analyses
questions_only = winnowed_info_df %>%
  select(one_of(c('experiment','dyad','participant',
                  questionnaire_variables, 'training_improvement'))) %>%
  
  # create a mean training improvement score for the dyad
  group_by(experiment, dyad) %>%
  mutate(training_improvement = mean(training_improvement)) %>%
  ungroup() %>%
  
  # select only the unique rows
  distinct() 

# merge into the ccf dataframe
ccf_df = full_join(questions_only, ccf_df,
                   by='dyad','experiment')

```

Let's clean up a bit before we move on.

```{r clean-up-variables}

# clean up unneeded variables
rm(p0_df,p1_df,binary_dfs, infos, questions_only)

```

### Create interaction terms

#### For `winnowed_info_df`

```{r create-interactions-winnowed}

# create interactions
winnowed_info_df = winnowed_info_df %>% ungroup() %>%
  
  # create a turn variable across trials and responses
  as.data.frame() %>%
  group_by(experiment,dyad,participant) %>%
  mutate(turn = row_number()) %>%
  ungroup() %>%
  
  # exclude training data
  dplyr::filter(trial_type=='test') %>%

  # survey interactions
  mutate(cooperative.both = cooperative_self * cooperative_partner) %>%
  mutate(trust.both = trust_self * trust_partner) %>%
  mutate(cooperative.trust.self = cooperative_self * trust_self) %>%
  mutate(cooperative.trust.partner = cooperative_partner * trust_partner) %>%
  
  # error interactions
  mutate(error.length = (normalized_error+.00001) * length) %>%
  mutate(error.turn = (normalized_error+.00001) * turn) %>%
  mutate(error.length.turn = (normalized_error+.00001) * turn * length) %>%
  
  # other interactions
  mutate(turn.training = turn * training_improvement)

```

```{r create-first-guess-df}

# spin off a dataset for only first answers
first_guess_df = winnowed_info_df %>% ungroup() %>%
  
  # grab just the final guess on each trial guess
  dplyr::filter(response_counter==1) %>%
  
  # filter out "turn" variables
  select(-contains("turn")) %>%
  
  # recreate the interactions at the trial level
  mutate(error.length = (normalized_error+.00001) * length) %>%
  mutate(error.trial = (normalized_error+.00001) * trial_number) %>%
  mutate(error.length.trial = (normalized_error+.00001) * trial_number * length) %>%
  mutate(trial.training = trial_number * training_improvement)

```

```{r create-final-guess-df}

# spin off a dataset for only final answers
final_guess_df = winnowed_info_df %>% ungroup() %>%
  
  # grab just the final guess on each trial guess
  group_by(experiment,dyad,participant,trial_number) %>%
  slice(n()) %>%
  ungroup() %>%
  
  # filter out "turn" variables
  select(-contains("turn")) %>%
  
  # recreate the error interactions at the trial level
  mutate(error.length = (normalized_error+.00001) * length) %>%
  mutate(error.trial = (normalized_error+.00001) * trial_number) %>%
  mutate(error.length.trial = (normalized_error+.00001) * trial_number * length) %>%
  mutate(trial.training = trial_number * training_improvement)

```

#### For `ccf_df`

```{r create-orthogonal-polynomials-ccf}

# create first- and second-order orthogonal polynomials for lag 
raw_lag = min(ccf_df$lag):max(ccf_df$lag)
lag_vals = data.frame(raw_lag)
lag_offset = (0-min(raw_lag)) + 1
t = stats::poly((raw_lag + lag_offset), 2)
lag_vals[, paste("lag_ot", 1:2, sep="")] = t[lag_vals$raw_lag + lag_offset, 1:2]

# join it to the original data table
ccf_df = left_join(ccf_df,lag_vals, by = c("lag" = "raw_lag"))

```

```{r create-interactions-ccf}

ccf_df = ccf_df %>% ungroup() %>%
  
  # create interactions among static variables of interest
  mutate(cooperative.both = cooperative_self * cooperative_partner) %>%
  mutate(trust.both = trust_self * trust_partner) %>%
  mutate(cooperative.trust.self = cooperative_self * trust_self) %>%
  mutate(cooperative.trust.partner = cooperative_partner * trust_partner) %>%

  # first-order polynomials with lag
  mutate(cooperative_self.lag_ot1 = cooperative_self * lag_ot1) %>%
  mutate(cooperative_partner.lag_ot1 = cooperative_partner * lag_ot1) %>%
  mutate(trust_self.lag_ot1 = trust_self * lag_ot1) %>%
  mutate(trust_partner.lag_ot1 = trust_partner * lag_ot1) %>%

  # first-order polynomials with lag
  mutate(cooperative_self.lag_ot2 = cooperative_self * lag_ot2) %>%
  mutate(cooperative_partner.lag_ot2 = cooperative_partner * lag_ot2) %>%
  mutate(trust_self.lag_ot2 = trust_self * lag_ot2) %>%
  mutate(trust_partner.lag_ot2 = trust_partner * lag_ot2) %>%
  
  # polynomial interactions
  mutate(lag_ot1.lag_ot2 = lag_ot1 * lag_ot2) %>%
  mutate(cooperative.both.lag_ot1.lag_ot2 = cooperative.both * lag_ot1 * lag_ot2) %>%
  mutate(trust.both.lag_ot1.lag_ot2 = trust_self * trust_partner * lag_ot1 * lag_ot2) %>%
  mutate(cooperative.trust.self.lag_ot1.lag_ot2 = cooperative_self * trust_self * lag_ot1 * lag_ot2) %>%
  mutate(cooperative.trust.partner.lag_ot1.lag_ot2 = cooperative_partner * trust_partner * lag_ot1 * lag_ot2)

```

### Create standardized datasets

#### For `winnowed_info_df`

```{r standardize-winnowed}

info_plot = winnowed_info_df %>% ungroup() %>%
  mutate_at(vars(participant,dyad),
            funs(factor))

info_st = winnowed_info_df %>% ungroup() %>%
  mutate_all(funs(as.numeric(scale(as.numeric(.))))) %>%
  mutate_at(vars(participant,dyad),
            funs(factor))

first_guess_plot = first_guess_df %>% ungroup() %>%
  mutate_at(vars(participant,dyad),
            funs(factor))

first_guess_st = first_guess_df %>% ungroup() %>%
  mutate_all(funs(as.numeric(scale(as.numeric(.))))) %>%
  mutate_at(vars(participant,dyad),
            funs(factor))
  
final_guess_plot = final_guess_df %>% ungroup() %>%
  mutate_at(vars(participant,dyad),
            funs(factor))
  
final_guess_st = final_guess_df %>% ungroup() %>%
  mutate_all(funs(as.numeric(scale(as.numeric(.))))) %>%
  mutate_at(vars(participant,dyad),
            funs(factor))

```

#### For `ccf_df`

```{r standardize-ccf}

# create unstandardized dataframe and convert relevant variables to factors
ccf_plot = ccf_df %>% ungroup() %>%
  mutate_at(vars(participant,dyad),
            funs(factor))
  
# create standardized dataframe and convert relevant variables to factors
ccf_st = ccf_df %>%
  mutate_all(funs(as.numeric(scale(as.numeric(.))))) %>%
  mutate_at(vars(participant,dyad),
            funs(factor))

```

```{r plot-all-variables, echo = FALSE}

# adapted from https://drsimonj.svbtle.com/quick-plot-of-all-variables
ccf_plot %>%
  mutate_all(funs(as.numeric)) %>%
  select(-contains("lag")) %>%
  select(-contains(".")) %>%
  gather() %>%                
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free") +
    geom_density() +
    xlab('Value') +
    ylab('Density') +
    ggtitle('Density plots of all variables (excluding lag and interactions)')

```

## Data analysis

Here are our preliminary questions:

* **When accounting for improvement during training, do individuals become more accurate over time...**
    * **... in their final guesses?** No, with non-significant trend toward "yes."
    * **... across all guesses?** No, with non-significant trend toward "yes."
    * **... in their first guesses?** While training improvement significantly predicts accuracy of first guess, there is also a non-significant trend toward "yes."

* **Are partners temporally coordinated in their guess accuracy across time?** Yes.

* **Do partners' ratings of their own and their partners' trustworthiness and cooperativity influence the dynamics of perceptual coordination?** No.

We also have some ideas that will shape future analyses.

* When we have more time:
    * *Are post-experiment ratings of cooperativity related to the directionality of change?  (That is, are people perceived as being more cooperative if they change their opinion to be more like their partner?)*
    * *Are post-experiment ratings of trustworthiness related to unwillingness to change? (That is, are people perceived as being more trustworthy if they stick to their initial guess?)*
    * *Are partners of consistently more reliable guessers more likely to adopt a strategy to minimize their own first-guess effort and then to simply mimic their partner?*
    * *Are partners of consistently poor guessers more likely to adopt a strategy to maximize their first guess and ignore their partner?*
    
* If we can get longer time series:
    * *Do partners become more similar across trials in the accuracy of their first guesses?*
    * *Do partners become more similar across trials in the accuracy of their last guesses?*
    * *Do partners become more similar within trials in their changes to their guesses?*

Notes for future work:

* Partners might think of this as a competition. If so, we should as a question to capture that.

### Do individuals become more accurate over time?

#### Do individuals become more accurate in their final guesses over time? 

```{r accurate-final-guess}

# standardized estimates
more_accurate_final_over_time_st = lmer(normalized_error ~ trial_number + training_improvement + trial.training +
                                 (1 + trial_number | participant)  +
                                 (1 + trial_number | dyad),
                               data = final_guess_st)
pander_lme(more_accurate_final_over_time_st, stats.caption = TRUE)

# raw estimates
more_accurate_final_over_time_raw = lmer(normalized_error ~ trial_number + training_improvement + trial.training +
                                 (1 + trial_number | participant)  +
                                 (1 + trial_number | dyad),
                               data = final_guess_plot)
pander_lme(more_accurate_final_over_time_raw, stats.caption = TRUE)

```

#### Do individuals become more accurate across all turns?

```{r}

# standardized estimates
more_accurate_over_all_time_st = lmer(normalized_error ~ turn + training_improvement + turn.training +
                                 (1 + turn | participant)  +
                                 (1 | dyad),
                               data = info_st)
pander_lme(more_accurate_over_all_time_st, stats.caption = TRUE)

# unstandardized estimates
more_accurate_over_all_time_raw = lmer(normalized_error ~ turn + training_improvement + turn.training +
                                 (1 + turn | participant)  +
                                 (1 | dyad),
                               data = info_plot)
pander_lme(more_accurate_over_all_time_raw, stats.caption = TRUE)

```

<!-- # # does it matter whether we consider error directionality? -->
<!-- # more_accurate_over_time_nondirectional = glmer(round(abs(normalized_error)*100,0) ~ turn + training_improvement + turn.training + -->
<!-- #                                  (1 | participant) + -->
<!-- #                                  (1 | dyad), -->
<!-- #                                data = info_plot, -->
<!-- #                                family=poisson) -->
<!-- # summary(more_accurate_over_time_nondirectional) -->


#### Do individuals become more accurate across first guesses?

```{r}

# standardized estimates
more_accurate_first_guesses_st = lmer(normalized_error ~ trial_number + training_improvement + trial.training +
                                    (1 + trial_number | participant)  +
                                    (1 | dyad),
                                  data = first_guess_st)
pander_lme(more_accurate_first_guesses_st, stats.caption = TRUE)

# unstandardized estimates
more_accurate_first_guesses_raw = lmer(normalized_error ~ trial_number + training_improvement + trial.training +
                                    (1 + trial_number | participant)  +
                                    (1 | dyad),
                                  data = first_guess_plot)
pander_lme(more_accurate_first_guesses_raw, stats.caption = TRUE)

```

```{r plot-error-of-first-guess, echo=FALSE}

ggplot(first_guess_plot, aes(x = trial_number,
                             y = normalized_error)) +
  geom_line(aes(color=factor(participant))) +
  scale_color_viridis(discrete=TRUE) +
  geom_smooth(method = "lm", se = FALSE) +
  theme(legend.position='none') +
  ylab('Normalized error') +
  xlab('Trial') +
  ggtitle('Normalized error of first guess on each trial')

```

### Do partners provide similar guesses?

```{r}

# standardized estimates
similar_partners_st = lmer(r ~ lag_ot1 + lag_ot2 + lag_ot1.lag_ot2 + training_improvement +
                               (1 + lag_ot1 + lag_ot2 + lag_ot1.lag_ot2 | dyad),
                             data = ccf_st)
pander_lme(similar_partners_st, stats.caption=TRUE)

# unstandardized estimates
similar_partners_raw = lmer(r ~ lag_ot1 + lag_ot2 + lag_ot1.lag_ot2 + training_improvement +
                               (1 + lag_ot1 + lag_ot2 + lag_ot1.lag_ot2 | dyad),
                             data = ccf_plot)
pander_lme(similar_partners_raw, stats.caption=TRUE)

```

```{r plot-ccf, echo=FALSE}

ggplot(ccf_df, aes(x = lag,
                     y = r)) +
  geom_jitter(aes(color = factor(dyad)), 
              height = 0,
              width = .15) +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1) +
  scale_color_viridis(discrete=TRUE) +
  theme(legend.position='none') + 
  xlab('Lag (in turns)') +
  ggtitle("Cross-correlation of partners' normalized error")

```

### Do ratings of cooperativity and trustworthiness influence adaptation?

```{r}

# standardized estimates
similar_partners_moderators_st = lmer(r ~ lag_ot1 + lag_ot2 + lag_ot1.lag_ot2 + training_improvement +
                                        trust_self + trust_self.lag_ot1 + trust_self.lag_ot2 +
                                        trust_partner + trust_partner.lag_ot1 + trust_partner.lag_ot2 +
                                        trust.both + 
                                        (1 + lag_ot1 + lag_ot2 + lag_ot1.lag_ot2 | dyad) +
                                        (1 | participant),
                                      data = ccf_st)
pander_lme(similar_partners_moderators_st, stats.caption=TRUE)

# unstandardized estimates
similar_partners_moderators_raw = lmer(r ~ lag_ot1 + lag_ot2 + lag_ot1.lag_ot2 + training_improvement +
                                        trust_self + trust_self.lag_ot1 + trust_self.lag_ot2 +
                                        trust_partner + trust_partner.lag_ot1 + trust_partner.lag_ot2 +
                                        trust.both + 
                                        (1 + lag_ot1 + lag_ot2 + lag_ot1.lag_ot2 | dyad) +
                                        (1 | participant),
                                       data = ccf_plot)
pander_lme(similar_partners_moderators_raw, stats.caption=TRUE)

```
